import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Component {
    int typeCode;
    int id;

    public Component(int typeCode, int id) {
	this.typeCode = typeCode;
	this.id = id;
    }
}

class ComponentConnection implements Cloneable {
    int id1;
    int id2;
    List<Integer> replacedIds;

    public ComponentConnection(int id1, int id2) {
	this.id1 = id1;
	this.id2 = id2;
	this.replacedIds = new ArrayList<Integer>();
    }

    @Override
    public ComponentConnection clone() throws CloneNotSupportedException {
	ComponentConnection clone = (ComponentConnection) super.clone();
	List<Integer> replacedIdsClone = new ArrayList<Integer>(
		replacedIds.size());
	clone.replacedIds = replacedIdsClone;
	return clone;
    }

    @Override
    public String toString() {
	return id1 + "-" + id2;
    }

}

class SeparatedPossibleResults {
    int category;
    List<ComponentConnection> possibleResults;

    public SeparatedPossibleResults(int category,
	    List<ComponentConnection> possibleResults) {
	this.category = category;
	this.possibleResults = possibleResults;
    }
}

interface IAction {
    public void act(int[] indices);
}

class NestedFor {

    private final int lo;
    private final int hi;
    private final IAction action;

    public NestedFor(int lo, int hi, IAction action) {
	this.lo = lo;
	this.hi = hi;
	this.action = action;
    }

    public void nFor(int depth) {
	n_for(0, new int[0], depth);
    }

    private void n_for(int level, int[] indices, int maxLevel) {
	if (level == maxLevel) {
	    action.act(indices);
	} else {
	    int newLevel = level + 1;
	    int[] newIndices = new int[newLevel];
	    System.arraycopy(indices, 0, newIndices, 0, level);
	    newIndices[level] = lo;
	    while (newIndices[level] < hi) {
		n_for(newLevel, newIndices, maxLevel);
		++newIndices[level];
	    }
	}
    }
}

public class Application {

    public static void main(String[] args) throws IOException {
	try {
	    List<Component> inputComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputConnections = new ArrayList<ComponentConnection>();

	    List<Component> inputErroneousComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputErroneousConnections = new ArrayList<ComponentConnection>();

	    List<ComponentConnection> possibleResults = new ArrayList<ComponentConnection>();

	    List<SeparatedPossibleResults> separatedPossibleResults = new ArrayList<SeparatedPossibleResults>();

	    List<ComponentConnection> results = new ArrayList<ComponentConnection>();

	    Application app = new Application();

	    app.parseComponentInputFile("inputs/GI0.in", inputComponents,
		    inputConnections);
	    app.parseComponentInputFile("inputs/GC0.in",
		    inputErroneousComponents, inputErroneousConnections);

	    for (Component inputErroneousComponent : inputErroneousComponents) {
		List<Component> matchedComponents = inputComponents.stream()
			.filter(c -> c.typeCode == inputErroneousComponent.typeCode)
			.collect(Collectors.toList());
		for (Component matchedComponent : matchedComponents) {
		    possibleResults.add(new ComponentConnection(
			    inputErroneousComponent.id, matchedComponent.id));
		}
	    }

	    for (Component inputErroneousComponent : inputErroneousComponents) {
		final List<ComponentConnection> separatedPossibleResult = possibleResults
			.stream()
			.filter(pr -> pr.id1 == inputErroneousComponent.id)
			.collect(Collectors.toList());
		separatedPossibleResults.add(new SeparatedPossibleResults(
			inputErroneousComponent.id, separatedPossibleResult));
	    }

	    for (int i = 0; i < inputErroneousComponents.size(); ++i) {
		final int depth = i;

		IAction testAction = new IAction() {
		    public void act(int[] indices) {
			try {
			    for (int i : indices) {
				for (ComponentConnection possibleResult : separatedPossibleResults
					.get(depth).possibleResults) {
				    List<ComponentConnection> copyInputErroneousConnections = app
					    .cloneList(
						    inputErroneousConnections);

				    app.replaceInList(
					    copyInputErroneousConnections,
					    possibleResult.id1,
					    possibleResult.id2);

				    if (app.checkIfEveryElementIsValidInputConnection(
					    copyInputErroneousConnections,
					    inputConnections)) {

					System.out.println(possibleResultOne.id1
						+ " - " + possibleResultOne.id2
						+ " " + possibleResultTwo.id1
						+ " - " + possibleResultTwo.id2
						+ " " + possibleResultThree.id1
						+ " - "
						+ possibleResultThree.id2);

				    }
				}
			    }
			} catch (CloneNotSupportedException e) {
			    e.printStackTrace();
			}
		    }
		};

		NestedFor nf = new NestedFor(0, inputErroneousComponents.size(),
			testAction);
		nf.nFor(depth);
	    }

	    for (ComponentConnection possibleResultOne : separatedPossibleResults
		    .get(0).possibleResults) {
		for (ComponentConnection possibleResultTwo : separatedPossibleResults
			.get(1).possibleResults) {
		    for (ComponentConnection possibleResultThree : separatedPossibleResults
			    .get(2).possibleResults) {
			List<ComponentConnection> copyInputErroneousConnections = app
				.cloneList(inputErroneousConnections);

			app.replaceInList(copyInputErroneousConnections,
				possibleResultOne.id1, possibleResultOne.id2);
			app.replaceInList(copyInputErroneousConnections,
				possibleResultTwo.id1, possibleResultTwo.id2);
			app.replaceInList(copyInputErroneousConnections,
				possibleResultThree.id1,
				possibleResultThree.id2);

			if (app.checkIfEveryElementIsValidInputConnection(
				copyInputErroneousConnections,
				inputConnections)) {

			    /*
			     * System.out.println(possibleResultOne.id1 + " - "
			     * + possibleResultOne.id2 + " " +
			     * possibleResultTwo.id1 + " - " +
			     * possibleResultTwo.id2 + " " +
			     * possibleResultThree.id1 + " - " +
			     * possibleResultThree.id2);
			     */

			}
		    }
		}
	    }

	} catch (Exception e) {
	    e.printStackTrace();
	}
    }

    private List<ComponentConnection> cloneList(List<ComponentConnection> list)
	    throws CloneNotSupportedException {
	List<ComponentConnection> clone = new ArrayList<ComponentConnection>(
		list.size());
	for (ComponentConnection item : list)
	    clone.add((ComponentConnection) item.clone());
	return clone;
    }

    private boolean checkIfEveryElementIsValidInputConnection(
	    List<ComponentConnection> toBeValidatedList,
	    List<ComponentConnection> inputConnections) {
	for (ComponentConnection toBeValidated : toBeValidatedList) {
	    boolean isValid = false;
	    for (ComponentConnection inputConnection : inputConnections) {
		if (toBeValidated.id1 == inputConnection.id1
			&& toBeValidated.id2 == inputConnection.id2) {
		    isValid = true;
		    break;
		}
	    }

	    if (!isValid) {
		return false;
	    }
	}
	return true;
    }

    private void replaceInList(List<ComponentConnection> list, int elementKey,
	    int element) {
	for (ComponentConnection listItem : list) {
	    if (!listItem.replacedIds.contains(0)
		    && listItem.id1 == elementKey) {
		listItem.id1 = element;
		listItem.replacedIds.add(0);
	    }

	    if (!listItem.replacedIds.contains(1)
		    && listItem.id2 == elementKey) {
		listItem.id2 = element;
		listItem.replacedIds.add(1);
	    }
	}
    }

    private void parseComponentInputFile(String fileName,
	    List<Component> inputComponents,
	    List<ComponentConnection> inputConnections) throws IOException {
	BufferedReader bufferReader = new BufferedReader(
		new FileReader(fileName));
	try {

	    String line;
	    int lineIndex = 0;

	    while ((line = bufferReader.readLine()) != null) {
		// read input components
		if (lineIndex == 0) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] components = pair.split("-");

			inputComponents.add(
				new Component(Integer.parseInt(components[0]),
					Integer.parseInt(components[1])));
		    }
		}

		// read input component connections
		if (lineIndex == 2) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] componentConnections = pair.split("-");

			inputConnections.add(new ComponentConnection(
				Integer.parseInt(componentConnections[0]),
				Integer.parseInt(componentConnections[1])));
		    }
		}

		lineIndex++;
	    }
	} catch (Exception e) {
	    e.printStackTrace();
	} finally {
	    bufferReader.close();
	}
    }

}
