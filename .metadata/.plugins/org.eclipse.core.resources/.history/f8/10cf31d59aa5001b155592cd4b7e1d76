package main;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

class Component {
    int typeCode;
    int id;

    public Component(int typeCode, int id) {
	this.typeCode = typeCode;
	this.id = id;
    }
}

class ComponentConnection implements Cloneable {
    int id1;
    int id2;
    List<Integer> replacedIndices;

    public ComponentConnection(int id1, int id2) {
	this.id1 = id1;
	this.id2 = id2;
	this.replacedIndices = new ArrayList<Integer>();
    }

    @Override
    protected ComponentConnection clone() throws CloneNotSupportedException {
	ComponentConnection clone = (ComponentConnection) super.clone();

	List<Integer> copy = new ArrayList<Integer>();
	for (Integer i : replacedIndices) {
	    copy.add(Integer.valueOf(i));
	}
	clone.replacedIndices = new ArrayList<Integer>(replacedIndices);

	return clone;
    }

    @Override
    public String toString() {
	return id1 + "-" + id2;
    }

}

public class Application {

    public static void main(String[] args) throws IOException {
	try {
	    List<Component> inputComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputConnections = new ArrayList<ComponentConnection>();

	    List<Component> inputErroneousComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputErroneousConnections = new ArrayList<ComponentConnection>();

	    List<Component> inputReplacementComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputReplacementConnections = new ArrayList<ComponentConnection>();

	    List<ComponentConnection> matchedComponents = new ArrayList<ComponentConnection>();

	    List<List<ComponentConnection>> separatedMatchedComponents = new ArrayList<List<ComponentConnection>>();

	    Application app = new Application();

	    app.parseComponentInputFile("inputs/GI0.in", inputComponents,
		    inputConnections);
	    app.parseComponentInputFile("inputs/GC0.in",
		    inputErroneousComponents, inputErroneousConnections);
	    app.parseComponentInputFile("inputs/GR0.in",
		    inputReplacementComponents, inputReplacementConnections);

	    matchedComponents = app.matchInputAndErroneousComponents(
		    inputComponents, inputErroneousComponents);

	    separatedMatchedComponents = app.separateMatchedComponentsIntoLists(
		    inputErroneousComponents, matchedComponents);

	    List<List<ComponentConnection>> matchableErroneousComponents = app
		    .getComponentCombinations(separatedMatchedComponents);

	    List<List<ComponentConnection>> matchedErroneousComponents = app
		    .findMatchingErroneouseComponents(
			    matchableErroneousComponents,
			    inputErroneousConnections, inputConnections);

	    int numReplacements = app.countComponentReplacements(
		    inputErroneousComponents, inputReplacementComponents,
		    matchedErroneousComponents);


	} catch (Exception e) {
	    e.printStackTrace();
	}
    }
    
    private String createOutputFileContent(int numReplacements, List<List<ComponentConnection>> matchedErroneousComponents) {
	String stringOutput = "";
	
	System.out.println(numReplacements);
	System.out.println(matchedErroneousComponents.get(0));
	
	stringOutput += String.valueOf(numReplacements) + "\n";
	
	for(List<ComponentConnection> matchedErroneousComponent : matchedErroneousComponents) {
	    stringOutput += matchedErroneousComponent + "\n";
	}
	
	return stringOutput;
    }

    private int countComponentReplacements(
	    List<Component> inputErroneousComponents,
	    List<Component> inputReplacementComponents,
	    List<List<ComponentConnection>> matchedErroneousComponents) {
	int numReplacements = 0;

	for (int i = 0; i < inputErroneousComponents.size(); i++) {
	    if (i < inputReplacementComponents.size()) {
		if (inputErroneousComponents
			.get(i).id != inputReplacementComponents.get(i).id) {
		    int toBeReplacedId = inputErroneousComponents.get(i).id;
		    List<Integer> alreadyReplacedIndices = new ArrayList<Integer>();

		    for (List<ComponentConnection> filteredResult : matchedErroneousComponents) {
			for (ComponentConnection connection : filteredResult) {
			    if (connection.id1 == toBeReplacedId
				    && !alreadyReplacedIndices
					    .contains(connection.id2)) {
				numReplacements++;
				alreadyReplacedIndices.add(connection.id2);
				break;
			    }
			}
		    }
		}
	    } else {
		break;
	    }
	}

	return numReplacements;
    }

    private List<List<ComponentConnection>> findMatchingErroneouseComponents(
	    List<List<ComponentConnection>> matchableErroneousComponents,
	    List<ComponentConnection> inputErroneousConnections,
	    List<ComponentConnection> inputConnections) {
	return matchableErroneousComponents.parallelStream().filter(result -> {
	    try {
		List<ComponentConnection> cloneList = this
			.cloneComponentConnectionList(
				inputErroneousConnections);

		for (ComponentConnection connection : result) {
		    this.replaceConnections(cloneList, connection);
		}

		return this.checkIfEveryElementIsValidInputConnection(cloneList,
			inputConnections);
	    } catch (CloneNotSupportedException e) {
		return false;
	    }
	}).collect(Collectors.toList());
    }

    private List<List<ComponentConnection>> separateMatchedComponentsIntoLists(
	    List<Component> inputErroneousComponents,
	    List<ComponentConnection> matchedComponents) {
	List<List<ComponentConnection>> separatedMatchedComponents = new ArrayList<List<ComponentConnection>>();

	for (Component inputErroneousComponent : inputErroneousComponents) {
	    final List<ComponentConnection> separatedPossibleResult = matchedComponents
		    .stream().filter(pr -> pr.id1 == inputErroneousComponent.id)
		    .collect(Collectors.toList());
	    separatedMatchedComponents.add(separatedPossibleResult);
	}

	return separatedMatchedComponents;
    }

    private List<ComponentConnection> matchInputAndErroneousComponents(
	    List<Component> inputComponents,
	    List<Component> inputErroneousComponents) {
	List<ComponentConnection> resultMatchedComponents = new ArrayList<ComponentConnection>();
	for (Component inputErroneousComponent : inputErroneousComponents) {
	    List<Component> matchedComponents = inputComponents.stream()
		    .filter(c -> c.typeCode == inputErroneousComponent.typeCode)
		    .collect(Collectors.toList());
	    for (Component matchedComponent : matchedComponents) {
		resultMatchedComponents.add(new ComponentConnection(
			inputErroneousComponent.id, matchedComponent.id));
	    }
	}

	return resultMatchedComponents;
    }

    private void replaceConnections(List<ComponentConnection> baseList,
	    ComponentConnection element) {
	for (ComponentConnection listElement : baseList) {
	    if (!listElement.replacedIndices.contains(0)
		    && listElement.id1 == element.id1) {
		listElement.id1 = element.id2;
		listElement.replacedIndices.add(0);
	    }

	    if (!listElement.replacedIndices.contains(1)
		    && listElement.id2 == element.id1) {
		listElement.id2 = element.id2;
		listElement.replacedIndices.add(1);
	    }
	}
    }

    private List<ComponentConnection> cloneComponentConnectionList(
	    List<ComponentConnection> cloneableConnectionList)
	    throws CloneNotSupportedException {
	Iterator<ComponentConnection> iterator = cloneableConnectionList
		.iterator();
	List<ComponentConnection> connectionListClone = new ArrayList<ComponentConnection>();

	while (iterator.hasNext()) {
	    connectionListClone
		    .add((ComponentConnection) iterator.next().clone());
	}

	return connectionListClone;
    }

    private List<List<ComponentConnection>> getComponentCombinations(
	    List<List<ComponentConnection>> lists) {
	long size = 1;
	final List<List<ComponentConnection>> copy = new ArrayList<List<ComponentConnection>>();
	for (List<ComponentConnection> list : lists) {
	    size *= list.size();
	    copy.add(new ArrayList<ComponentConnection>(list));
	}
	final int fSize = (int) size;
	return new AbstractList<List<ComponentConnection>>() {

	    @Override
	    public int size() {
		return fSize;
	    }

	    @Override
	    public List<ComponentConnection> get(int i) {
		ComponentConnection[] arr = new ComponentConnection[copy
			.size()];
		for (int j = copy.size() - 1; j >= 0; j--) {
		    List<ComponentConnection> list = copy.get(j);
		    arr[j] = list.get(i % list.size());
		    i /= list.size();
		}
		return Arrays.asList(arr);
	    }
	};
    }

    private boolean checkIfEveryElementIsValidInputConnection(
	    List<ComponentConnection> toBeValidatedList,
	    List<ComponentConnection> inputConnections) {
	for (ComponentConnection toBeValidated : toBeValidatedList) {
	    boolean isValid = false;
	    for (ComponentConnection inputConnection : inputConnections) {
		if (toBeValidated.id1 == inputConnection.id1
			&& toBeValidated.id2 == inputConnection.id2) {
		    isValid = true;
		    break;
		}
	    }

	    if (!isValid) {
		return false;
	    }
	}
	return true;
    }

    private void writeIntoFile(String fileName, String content) {
	try {
	    FileWriter file = new FileWriter(fileName);
	    BufferedWriter bufferedWriter = new BufferedWriter(file);

	    bufferedWriter.write(content);

	    bufferedWriter.close();
	} catch (IOException e) {
	    e.printStackTrace();
	} finally {

	}
    }

    private void parseComponentInputFile(String fileName,
	    List<Component> inputComponents,
	    List<ComponentConnection> inputConnections) throws IOException {
	BufferedReader bufferReader = new BufferedReader(
		new FileReader(fileName));
	try {

	    String line;
	    int lineIndex = 0;

	    while ((line = bufferReader.readLine()) != null) {
		// read input components
		if (lineIndex == 0) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] components = pair.split("-");

			inputComponents.add(
				new Component(Integer.parseInt(components[0]),
					Integer.parseInt(components[1])));
		    }
		}

		// read input component connections
		if (lineIndex == 2) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] componentConnections = pair.split("-");

			inputConnections.add(new ComponentConnection(
				Integer.parseInt(componentConnections[0]),
				Integer.parseInt(componentConnections[1])));
		    }
		}

		lineIndex++;
	    }
	} catch (Exception e) {
	    e.printStackTrace();
	} finally {
	    bufferReader.close();
	}
    }

}
