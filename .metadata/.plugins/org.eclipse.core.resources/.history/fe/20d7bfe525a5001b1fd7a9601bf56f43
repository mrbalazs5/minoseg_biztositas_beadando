package main;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

class Component {
    int typeCode;
    int id;

    public Component(int typeCode, int id) {
	this.typeCode = typeCode;
	this.id = id;
    }
}

class ComponentConnection implements Cloneable {
    int id1;
    int id2;
    List<Integer> replacedIndices;

    public ComponentConnection(int id1, int id2) {
	this.id1 = id1;
	this.id2 = id2;
	this.replacedIndices = new ArrayList<Integer>();
    }

    @Override
    protected ComponentConnection clone() throws CloneNotSupportedException {
	ComponentConnection clone = (ComponentConnection) super.clone();

	List<Integer> copy = new ArrayList<Integer>();
	for (Integer i : replacedIndices) {
	    copy.add(Integer.valueOf(i));
	}
	clone.replacedIndices = new ArrayList<Integer>(replacedIndices);

	return clone;
    }

    @Override
    public String toString() {
	return id1 + "-" + id2;
    }

}

public class Application {

    public static void main(String[] args) throws IOException {
	try {
	    List<Component> inputComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputConnections = new ArrayList<ComponentConnection>();

	    List<Component> inputErroneousComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputErroneousConnections = new ArrayList<ComponentConnection>();

	    List<Component> inputReplacementComponents = new ArrayList<Component>();
	    List<ComponentConnection> inputReplacementConnections = new ArrayList<ComponentConnection>();

	    List<ComponentConnection> possibleResults = new ArrayList<ComponentConnection>();

	    List<List<ComponentConnection>> separatedPossibleResults = new ArrayList<List<ComponentConnection>>();

	    Application app = new Application();

	    app.parseComponentInputFile("inputs/GI0.in", inputComponents,
		    inputConnections);
	    app.parseComponentInputFile("inputs/GC0.in",
		    inputErroneousComponents, inputErroneousConnections);
	    app.parseComponentInputFile("inputs/GR0.in",
		    inputReplacementComponents, inputReplacementConnections);

	    possibleResults = app.matchInputAndErroneousComponents(
		    inputComponents, inputErroneousComponents);

	    List<List<ComponentConnection>> results = app
		    .getComponentCombinations(separatedPossibleResults);

	    List<List<ComponentConnection>> filteredResults = results
		    .parallelStream().filter(result -> {
			try {
			    List<ComponentConnection> cloneList = app
				    .cloneComponentConnectionList(
					    inputErroneousConnections);

			    for (ComponentConnection connection : result) {
				app.replaceConnections(cloneList, connection);
			    }

			    return app
				    .checkIfEveryElementIsValidInputConnection(
					    cloneList, inputConnections);
			} catch (CloneNotSupportedException e) {
			    return false;
			}
		    }).collect(Collectors.toList());

	    int numReplacements = 0;

	    for (int i = 0; i < inputErroneousComponents.size(); i++) {
		if (i < inputReplacementComponents.size()) {
		    if (inputErroneousComponents.get(
			    i).id != inputReplacementComponents.get(i).id) {
			int toBeReplacedId = inputErroneousComponents.get(i).id;
			List<Integer> alreadyReplacedIndices = new ArrayList<Integer>();

			for (List<ComponentConnection> filteredResult : filteredResults) {
			    for (ComponentConnection connection : filteredResult) {
				if (connection.id1 == toBeReplacedId
					&& !alreadyReplacedIndices
						.contains(connection.id2)) {
				    numReplacements++;
				    alreadyReplacedIndices.add(connection.id2);
				    break;
				}
			    }
			}
		    }
		} else {
		    break;
		}
	    }

	    System.out.println(numReplacements);
	    System.out.println(filteredResults.get(0));

	} catch (Exception e) {
	    e.printStackTrace();
	}
    }

    private void replaceConnections(List<ComponentConnection> baseList,
	    ComponentConnection element) {
	for (ComponentConnection listElement : baseList) {
	    if (!listElement.replacedIndices.contains(0)
		    && listElement.id1 == element.id1) {
		listElement.id1 = element.id2;
		listElement.replacedIndices.add(0);
	    }

	    if (!listElement.replacedIndices.contains(1)
		    && listElement.id2 == element.id1) {
		listElement.id2 = element.id2;
		listElement.replacedIndices.add(1);
	    }
	}
    }

    private List<List<ComponentConnection>> separateMatchedComponentsIntoLists(
	    List<Component> inputErroneousComponents,
	    List<ComponentConnection> matchedComponents) {
	List<List<ComponentConnection>> separatedMatchedComponents = new ArrayList<List<ComponentConnection>>();
	
	for (Component inputErroneousComponent : inputErroneousComponents) {
	    final List<ComponentConnection> separatedPossibleResult = matchedComponents
		    .stream().filter(pr -> pr.id1 == inputErroneousComponent.id)
		    .collect(Collectors.toList());
	    separatedMatchedComponents.add(separatedPossibleResult);
	}
	
	return separatedMatchedComponents;
    }

    private List<ComponentConnection> matchInputAndErroneousComponents(
	    List<Component> inputComponents,
	    List<Component> inputErroneousComponents) {
	List<ComponentConnection> resultMatchedComponents = new ArrayList<ComponentConnection>();
	for (Component inputErroneousComponent : inputErroneousComponents) {
	    List<Component> matchedComponents = inputComponents.stream()
		    .filter(c -> c.typeCode == inputErroneousComponent.typeCode)
		    .collect(Collectors.toList());
	    for (Component matchedComponent : matchedComponents) {
		resultMatchedComponents.add(new ComponentConnection(
			inputErroneousComponent.id, matchedComponent.id));
	    }
	}

	return resultMatchedComponents;
    }

    private List<ComponentConnection> cloneComponentConnectionList(
	    List<ComponentConnection> cloneableConnectionList)
	    throws CloneNotSupportedException {
	Iterator<ComponentConnection> iterator = cloneableConnectionList
		.iterator();
	List<ComponentConnection> connectionListClone = new ArrayList<ComponentConnection>();

	while (iterator.hasNext()) {
	    connectionListClone
		    .add((ComponentConnection) iterator.next().clone());
	}

	return connectionListClone;
    }

    private List<List<ComponentConnection>> getComponentCombinations(
	    List<List<ComponentConnection>> lists) {
	long size = 1;
	final List<List<ComponentConnection>> copy = new ArrayList<List<ComponentConnection>>();
	for (List<ComponentConnection> list : lists) {
	    size *= list.size();
	    copy.add(new ArrayList<ComponentConnection>(list));
	}
	final int fSize = (int) size;
	return new AbstractList<List<ComponentConnection>>() {

	    @Override
	    public int size() {
		return fSize;
	    }

	    @Override
	    public List<ComponentConnection> get(int i) {
		ComponentConnection[] arr = new ComponentConnection[copy
			.size()];
		for (int j = copy.size() - 1; j >= 0; j--) {
		    List<ComponentConnection> list = copy.get(j);
		    arr[j] = list.get(i % list.size());
		    i /= list.size();
		}
		return Arrays.asList(arr);
	    }
	};
    }

    private boolean checkIfEveryElementIsValidInputConnection(
	    List<ComponentConnection> toBeValidatedList,
	    List<ComponentConnection> inputConnections) {
	for (ComponentConnection toBeValidated : toBeValidatedList) {
	    boolean isValid = false;
	    for (ComponentConnection inputConnection : inputConnections) {
		if (toBeValidated.id1 == inputConnection.id1
			&& toBeValidated.id2 == inputConnection.id2) {
		    isValid = true;
		    break;
		}
	    }

	    if (!isValid) {
		return false;
	    }
	}
	return true;
    }

    private void parseComponentInputFile(String fileName,
	    List<Component> inputComponents,
	    List<ComponentConnection> inputConnections) throws IOException {
	BufferedReader bufferReader = new BufferedReader(
		new FileReader(fileName));
	try {

	    String line;
	    int lineIndex = 0;

	    while ((line = bufferReader.readLine()) != null) {
		// read input components
		if (lineIndex == 0) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] components = pair.split("-");

			inputComponents.add(
				new Component(Integer.parseInt(components[0]),
					Integer.parseInt(components[1])));
		    }
		}

		// read input component connections
		if (lineIndex == 2) {
		    final String[] splittedPairs = line.split(";");

		    for (String pair : splittedPairs) {
			final String[] componentConnections = pair.split("-");

			inputConnections.add(new ComponentConnection(
				Integer.parseInt(componentConnections[0]),
				Integer.parseInt(componentConnections[1])));
		    }
		}

		lineIndex++;
	    }
	} catch (Exception e) {
	    e.printStackTrace();
	} finally {
	    bufferReader.close();
	}
    }

}
